<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Aadhaar — Auto QR Scan & Decode (Improved)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Bootstrap just for quick UI -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">

  <!-- ZXing (stronger QR reader), pako (decompress), jsQR (fallback simple reader) -->
  <script src="https://unpkg.com/@zxing/browser@0.0.10/dist/index.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>

  <style>
    body { max-width: 980px; margin: 20px auto; font-family: system-ui, Roboto, Arial; }
    #video { width: 100%; max-height: 480px; border-radius: 8px; background: #000; object-fit: cover; }
    pre { white-space: pre-wrap; background: #f8f9fa; padding: 12px; border-radius: 8px; border: 1px solid #dee2e6; }
    .dot { width: 12px; height: 12px; border-radius: 50%; display: inline-block; margin-left: 8px; }
    .ok { background: #198754; }
    .bad { background: #dc3545; }
  </style>
</head>
<body class="bg-light">
  <div class="container">
    <h2 class="mb-3">Aadhaar — Auto QR Scan & Decode (Improved)</h2>
    <p class="text-muted small">Use back camera on mobile. ZXing is used for robust decoding. If live camera fails, upload image.</p>

    <div class="card mb-3">
      <div class="card-body text-center">
        <video id="video" autoplay playsinline class="mb-3"></video>
        <div class="d-flex flex-wrap gap-2 justify-content-center mb-2">
          <button id="stopBtn" class="btn btn-danger">Stop Camera</button>
          <button id="startBtn" class="btn btn-success">Start Camera</button>
          <label class="btn btn-primary mb-0">
            Upload image <input id="fileInput" type="file" accept="image/*" hidden>
          </label>
          <button id="resetBtn" class="btn btn-secondary">Reset</button>
        </div>

        <div class="mt-2 d-flex align-items-center justify-content-center">
          <span>Status: <span id="statusText">Ready</span></span>
          <span id="statusDot" class="dot bad"></span>
        </div>
        <div id="errorMsg" class="mt-2 text-danger"></div>
      </div>
    </div>

    <h4>Decoded Output</h4>
    <pre id="out">(no output yet)</pre>
  </div>

  <script>
    /* ------------------ Utilities (kept from your original) ------------------ */
    function bigIntDecimalToBytes(decStr) {
      decStr = (decStr || "").replace(/\D/g, '');
      if (!decStr) return new Uint8Array([]);
      const bi = BigInt(decStr);
      if (bi === 0n) return new Uint8Array([0]);
      let hex = bi.toString(16);
      if (hex.length % 2) hex = "0" + hex;
      const u8 = new Uint8Array(hex.length / 2);
      for (let i = 0; i < u8.length; i++) u8[i] = Number("0x" + hex.substr(i * 2, 2));
      return u8;
    }
    function tryDecompress(u8) {
      try { return pako.ungzip(u8); } catch (e) { }
      try { return pako.inflate(u8); } catch (e) { }
      throw new Error("Decompress failed");
    }
    function splitUntilFF(u8, count) {
      const parts = []; let cursor = 0;
      for (let i = 0; i < count; i++) {
        const idx = u8.indexOf(0xFF, cursor);
        if (idx === -1) throw new Error("Missing 0xFF");
        parts.push(u8.slice(cursor, idx));
        cursor = idx + 1;
      }
      return { parts, cursor };
    }
    function parseUidaiBytes(decompressed) {
      const FIELD_17 = ["version", "presenceBit", "referenceId", "name", "dob", "gender", "careOf", "district", "landmark", "house", "location", "pincode", "postOffice", "state", "street", "subDistrict", "vtc"];
      const FIELD_16 = ["presenceBit", "referenceId", "name", "dob", "gender", "careOf", "district", "landmark", "house", "location", "pincode", "postOffice", "state", "street", "subDistrict", "vtc"];
      let partsInfo, FIELD_ORDER;
      try { partsInfo = splitUntilFF(decompressed, FIELD_17.length); FIELD_ORDER = FIELD_17; }
      catch (e) { partsInfo = splitUntilFF(decompressed, FIELD_16.length); FIELD_ORDER = FIELD_16; }
      const td = new TextDecoder("iso-8859-1");
      const parts = partsInfo.parts;
      const values = parts.map((p, i) => i === 0 ? td.decode(p).trim() : td.decode(p));
      const data = {}; FIELD_ORDER.forEach((k, i) => data[k] = values[i] ?? "");
      return { data };
    }

    /* ------------------ UI elements ------------------ */
    const video = document.getElementById("video");
    const stopBtn = document.getElementById("stopBtn");
    const startBtn = document.getElementById("startBtn");
    const resetBtn = document.getElementById("resetBtn");
    const outEl = document.getElementById("out");
    const statusText = document.getElementById("statusText");
    const statusDot = document.getElementById("statusDot");
    const fileInput = document.getElementById("fileInput");
    const errorMsg = document.getElementById("errorMsg");

    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");

    function setStatus(s, ok) {
      statusText.textContent = s;
      statusDot.className = "dot " + (ok ? "ok" : "bad");
    }

    /* ------------------ Preprocessing helpers ------------------ */
    // Convert imageData to improved contrast grayscale and optionally apply adaptive thresholding.
    function preprocessImageData(imgData, options = { threshold: true, sharpen: true }) {
      const d = imgData.data;
      const w = imgData.width, h = imgData.height;

      // First convert to grayscale (luma)
      for (let i = 0; i < d.length; i += 4) {
        // luma formula
        const l = 0.2126 * d[i] + 0.7152 * d[i+1] + 0.0722 * d[i+2];
        d[i] = d[i+1] = d[i+2] = l;
      }

      // Optional: simple unsharp mask (sharpen) for blurry xerox
      if (options.sharpen) {
        // lightweight 3x3 unsharp-ish kernel
        const copy = new Uint8ClampedArray(d);
        const kernel = [-1,-1,-1,-1,16,-1,-1,-1,-1]; // sums to 0 -> sharpen
        let kIdx = 0;
        for (let y = 1; y < h-1; y++) {
          for (let x = 1; x < w-1; x++) {
            let acc = 0;
            kIdx = 0;
            for (let ky = -1; ky <= 1; ky++) {
              for (let kx = -1; kx <= 1; kx++) {
                const px = x + kx;
                const py = y + ky;
                const idx = (py * w + px) * 4;
                acc += copy[idx] * kernel[kIdx++];
              }
            }
            const idxC = (y * w + x) * 4;
            const v = Math.min(255, Math.max(0, acc / 8)); // normalize
            d[idxC] = d[idxC+1] = d[idxC+2] = v;
          }
        }
      }

      // Optional: global threshold (helps xerox)
      if (options.threshold) {
        // compute median-ish threshold quickly by sampling
        const sample = [];
        for (let i = 0; i < d.length; i += Math.floor(d.length / 1000) * 4 || 4) sample.push(d[i]);
        sample.sort((a,b) => a-b);
        const med = sample[Math.floor(sample.length/2)] || 128;
        const t = med * 0.95; // slightly below median
        for (let i = 0; i < d.length; i += 4) {
          const v = d[i] > t ? 255 : 0;
          d[i] = d[i+1] = d[i+2] = v;
        }
      }

      return imgData;
    }

    /* ------------------ ZXing setup ------------------ */
    const zx = window.ZXingBrowser || (window.ZXing && window.ZXing.BrowserQRCodeReader ? window.ZXing : null);
    // In the unpkg bundle, the global is at window.ZXingBrowser or window.ZXing depending on version.
    let codeReader = null;
    try { codeReader = zx ? new zx.BrowserQRCodeReader() : null; } catch (e) { codeReader = null; }

    let currentStream = null;
    let zxingRunning = false;

    async function startCamera() {
      setStatus("starting camera...", false);
      errorMsg.textContent = "";
      outEl.textContent = "(no output yet)";

      // camera constraints - prefer back camera and allow autofocus if possible
      const constraints = {
        video: {
          facingMode: { ideal: "environment" },
          width: { ideal: 1280 },
          height: { ideal: 720 }
          // focusMode is not widely supported; browsers may ignore it.
        },
        audio: false
      };

      try {
        // Stop existing
        stopCamera(false);

        currentStream = await navigator.mediaDevices.getUserMedia(constraints);
        // attach stream
        video.srcObject = currentStream;
        await video.play();
        setStatus("camera started", true);

        // Try ZXing video decode (it manages its own loop)
        if (codeReader) {
          zxingRunning = true;
          // decodeFromVideoDevice(deviceId, videoElement, callback)
          // pass null to use default device
          codeReader.decodeFromVideoDevice(null, video, (result, err) => {
            if (result) {
              // Got a ZXing result
              onQRCodeFound(result.getText ? result.getText() : result.text);
            } else {
              // no result yet; keep scanning
              // fallback visual status
              setStatus("scanning (ZXing)...", true);
            }
          }).catch(e => {
            // ZXing failed to start -> fall back to manual loop
            console.warn("ZXing decodeFromVideoDevice failed:", e);
            zxingRunning = false;
            // Start manual JS loop
            manualScanLoop();
          });
        } else {
          // No ZXing available -> fallback to manual loop
          manualScanLoop();
        }
      } catch (err) {
        console.error(err);
        setStatus("camera error", false);
        errorMsg.textContent = "Camera start failed: " + (err.message || err);
        stopCamera(false);
      }
    }

    function stopCamera(stopVideoElement = true) {
      // stop ZXing if running
      try {
        if (codeReader && zxingRunning) {
          codeReader.reset(); // stops video decoding loop
        }
      } catch (e) { /* ignore */ }
      zxingRunning = false;

      if (currentStream) {
        currentStream.getTracks().forEach(t => t.stop());
        currentStream = null;
      }
      if (stopVideoElement) {
        video.pause();
        video.srcObject = null;
      }
      setStatus("camera stopped", false);
    }

    // If ZXing fails, we run a manual loop with preprocessing + jsQR fallback.
    let manualLoopHandle = null;
    async function manualScanLoop() {
      setStatus("scanning (manual)...", true);
      function loop() {
        if (!video || video.readyState !== video.HAVE_ENOUGH_DATA) {
          manualLoopHandle = requestAnimationFrame(loop);
          return;
        }
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        let imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        imgData = preprocessImageData(imgData, { threshold: true, sharpen: true });
        ctx.putImageData(imgData, 0, 0);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

        // Try jsQR first (works on preprocessed binary)
        try {
          const code = jsQR(imageData.data, imageData.width, imageData.height, { inversionAttempts: "attemptBoth" });
          if (code && code.data) {
            cancelAnimationFrame(manualLoopHandle);
            manualLoopHandle = null;
            onQRCodeFound(code.data);
            return;
          }
        } catch (e) { /* ignore */ }

        // If no QR, continue loop
        manualLoopHandle = requestAnimationFrame(loop);
      }
      manualLoopHandle = requestAnimationFrame(loop);
    }

    /* ------------------ QR result handling & Aadhaar parse ------------------ */
    async function onQRCodeFound(qrStr) {
      setStatus("QR found — decoding...", true);
      // Stop camera scanning loops & ZXing
      try {
        if (codeReader && zxingRunning) codeReader.reset();
      } catch (e) { }
      if (manualLoopHandle) { cancelAnimationFrame(manualLoopHandle); manualLoopHandle = null; }
      try {
        if (currentStream) { currentStream.getTracks().forEach(t => t.stop()); currentStream = null; }
        video.pause(); video.srcObject = null;
      } catch (e) { }

      try {
        // ZXing sometimes returns URI-like content; we only need digits for UIDAI payload
        const numeric = (String(qrStr).match(/[0-9]+/g) || []).join("");
        if (!numeric) throw new Error("No numeric content found in QR");

        // convert decimal big-int to bytes and decompress
        const raw = bigIntDecimalToBytes(numeric);
        const decompressed = tryDecompress(raw);

        // parse uidai bytes
        const parsed = parseUidaiBytes(decompressed);
        const d = parsed.data;
        const out = {
          name: d.name || "", dob: d.dob || "", gender: d.gender || "", careOf: d.careOf || "",
          district: d.district || "", landmark: d.landmark || "", house: d.house || "", location: d.location || "",
          pincode: d.pincode || "", postOffice: d.postOffice || "", state: d.state || "", street: d.street || "",
          subDistrict: d.subDistrict || "", vtc: d.vtc || ""
        };
        let text = "";
        for (const k of Object.keys(out)) text += `${k}: ${out[k] ?? ""}\n`;
        outEl.textContent = text;
        setStatus("decoded successfully", true);
      } catch (err) {
        outEl.textContent = "Error: " + (err?.message || String(err));
        setStatus("decode error", false);
        console.error(err);
      }
    }

    /* ------------------ File input (image upload) — preprocess then decode ------------------ */
    fileInput.addEventListener("change", async (ev) => {
      if (!ev.target.files || !ev.target.files[0]) return;
      const f = ev.target.files[0];
      const img = new Image();
      img.onload = async () => {
        // draw to canvas at reasonable size (limit to 1600px)
        const maxDim = 1600;
        let w = img.width, h = img.height;
        if (Math.max(w, h) > maxDim) {
          const ratio = maxDim / Math.max(w, h);
          w = Math.round(w * ratio); h = Math.round(h * ratio);
        }
        canvas.width = w; canvas.height = h;
        ctx.drawImage(img, 0, 0, w, h);

        // preprocess
        let imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        imgData = preprocessImageData(imgData, { threshold: true, sharpen: true });
        ctx.putImageData(imgData, 0, 0);

        setStatus("decoding uploaded image...", true);
        // Try ZXing decodeFromImage or fallback to jsQR
        try {
          if (codeReader) {
            // convert canvas to data URL
            const dataUrl = canvas.toDataURL("image/png");
            // decodeFromImage takes an <img> element, but the browser bundle also exposes decodeFromImage
            // For safety we use decodeFromImage using an image element
            const uploadImg = new Image();
            uploadImg.onload = async () => {
              try {
                const result = await codeReader.decodeFromImageElement(uploadImg);
                if (result && (result.getText ? result.getText() : result.text)) {
                  await onQRCodeFound(result.getText ? result.getText() : result.text);
                  return;
                } else {
                  throw new Error("ZXing decoded nothing");
                }
              } catch (e) {
                console.warn("ZXing image decode failed, falling back to jsQR:", e);
                // fallback: use jsQR on processed canvas
                fallbackJsQR();
              }
            };
            uploadImg.src = dataUrl;
            return;
          } else {
            fallbackJsQR();
          }
        } catch (e) {
          console.warn("image decode path failed:", e);
          fallbackJsQR();
        }

        function fallbackJsQR() {
          try {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const code = jsQR(imageData.data, imageData.width, imageData.height, { inversionAttempts: "attemptBoth" });
            if (code && code.data) onQRCodeFound(code.data);
            else {
              setStatus("no QR detected in image", false);
              errorMsg.textContent = "No QR detected in the uploaded image.";
            }
          } catch (e) {
            setStatus("error", false);
            errorMsg.textContent = "Image decode failed: " + (e.message || e);
          }
        }
      };
      img.onerror = () => {
        errorMsg.textContent = "Failed to load image file.";
      };
      img.src = URL.createObjectURL(f);
    });

    /* ------------------ Buttons ------------------ */
    stopBtn.addEventListener("click", () => { stopCamera(true); });
    startBtn.addEventListener("click", () => { startCamera(); });
    resetBtn.addEventListener("click", () => {
      outEl.textContent = "(no output yet)";
      errorMsg.textContent = "";
      setStatus("Ready", false);
      if (!currentStream) startCamera();
    });

    // start automatically
    (async () => {
      try { await startCamera(); } catch (e) { console.warn(e); }
    })();

    // cleanup when leaving page
    window.addEventListener("beforeunload", () => { stopCamera(true); });
  </script>
</body>
</html>
